#  The sequence of triangle numbers is generated by adding the natural numbers. 
#  So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
#   1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 
#   What is the value of the first triangle number to have over five hundred divisors?


import time
import unittest
from numpy import prod

class Triangular_Iterator:

	def __init__(self,place):
		self.place=place
		self.ti=sum([i for i in range(1,place+1)])

	def __iter__(self):
		return self

	def next(self):
		self.place+=1
		self.ti=self.ti+self.place
		return self.ti

def isprime(num):

	if num==0 or num==1:
		return 0
	elif num==2 or num==3:
		return 1
	elif num%2==0:
		return 0
	else:
		for i in range(3,int(num**0.5)+1,2):
			if num%i==0:
				return 0
	return 1

def count_factor(num):

	count=2

	if isprime(num):#optimize prime function
		return count

	elif (num**0.5)%1==0:
		count+=1
		largest_possible_factor=int(num**0.5)-1

	else:
		largest_possible_factor=int(num**0.5)

	for i in range(2,largest_possible_factor+1):
		if num%i==0:
			count+=2

	return count

def find_prime_factors(num):
	factors=list()

	if isprime(num):#optimize prime function
		factors.append(num)
		return factors

	else:
		square_root=num**0.5

		#if the number is perect square
		if square_root%1==0:
			root_factors=find_prime_factors(square_root)
			factors.extend(root_factors)
			factors.extend(root_factors)

		else:
			largest_possible_factor=int(square_root)

			for i in range(largest_possible_factor,1,-1):
					if num%i==0:
						factors.extend(find_prime_factors(i))
						factors.extend(find_prime_factors(int(num/i)))
						break

		return factors

def count_prime_factors(num):
	factors=find_prime_factors(num)
	prime_factors=dict()
	for factor in factors:
		prime_factors[factor]=prime_factors.get(factor,0)+1
	return prod([prime_factors[key]+1 for key in prime_factors])


def find_triangular_with_n_factors(factors):

	series=Triangular_Iterator(factors+1)
	print('\n')

	while(True):
		try:
			num=series.next()
			if count_factor(num)<factors:
				pass
			else:
				raise StopIteration
		except StopIteration:
			break
	print(num)

def find_triangular_with_n_factors_without_Iterator(factors):

	place=1
	num=1

	while(count_factor(num)<factors):
		place+=1
		num+=place

	print(num)

#http://www.gmathacks.com/gmat-math/number-of-factors-of-a-large-integer.html
#number of factors=find all prime factors->add 1 to power of each->multiply all powers
def find_triangular_with_n_factors_gmat_hack(factors):

	series=Triangular_Iterator(factors+1)
	print('\n')

	while(True):
		try:
			num=series.next()
			if count_prime_factors(num)<factors:
				pass
			else:
				raise StopIteration
		except StopIteration:
			break
	print(num)



class Test(unittest.TestCase):

	@unittest.skip("demonstrating skipping")
	def test_count_factor(self):
		self.assertEqual(count_factor(2),2)
		self.assertEqual(count_factor(4),3)
		self.assertEqual(count_factor(6),4)
		self.assertEqual(count_factor(28),6)

	#@unittest.skip("demonstrating skipping")
	def test_find_triangular_with_n_factors(self):
		self.assertEqual(find_triangular_with_n_factors(500),76576500)
		self.assertEqual(find_triangular_with_n_factors_without_Iterator(500),76576500)
		self.assertEqual(find_triangular_with_n_factors_gmat_hack(500),76576500)


	@unittest.skip("skipping")
	def test_find_factors(self):
		print('\n')
		print(find_prime_factors(200))

	@unittest.skip("skip")
	def test_count_prime_factors(self):
		print('\n')
		print(count_factor(1300))
		print(count_prime_factors(1300))

		

if __name__ == '__main__':
	unittest.main()




